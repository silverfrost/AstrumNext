@title Astrum Next Manual
@author Robert Chafer
@version 1.0
@copyright Copyright (C)2025 Robert Chafer, all rights reserved.

@-------------------------------------------------------------------------------
@node MAIN
@next KEYS
@{c}@{h1}Astrum Next
Astrum+ was an editor and assembler for the original Sinclair Spectrum 48K with
an Interface 1 and at least one Microdrive. There were also versions for the
Opus Discovery and Disciple / Plus D drives. It was written to make the task of
writing large assembly language easier. Previous assemblers were very limited
on the size of the source files they allowed. Astrum allowed source code to be
written in 10K pages. It allowed the user to move quickly between the pages and
would chain them altogether when assembling. In 1986 this felt like the future!

Astrum Next tries to keep the vibe of the original Astrum but, of course, takes
advantage of some of the improved features the Spectrum Next has to offer.
In particular you don't have source code pages anymore and Astrum can handle
much larger sized source files, certainly over 128kB. I am happy to say that
quite a lot of the original source code remains - in the assembler in
particular.

Topics:
@{" Editor Keys " LINK KEYS}
@{" Assembler  " LINK ASSEMBLER}
@{" Debugger  " LINK DEBUG}

@node KEYS
@prev MAIN
@{c}@{h1}Editor Keys
In the list of keys, SS is Symbol Shift and CS is Caps Shift


@{h2}Menu
SS Q - Move highlight to File menu
SS W - Show/hide highlighted menu
SS E - Select menu item

@{h2}Edit keys
INV VIDEO  - Page down
TRUE VIDEO - Page up
EDIT       - Undo changes to line
GRAPH      - End of line
CS SPACE   - Next tab
SS A       - ~
SS S       - |
SS D       - \
SS F       - {
SS G       - }
ENTER      - New line
CS ENTER   - New line above
SS ENTER   - Split line at cursor

@{h2}Extended keys - press EXTEND MODE.
The border and status area will go red andï¿½
wait for a key:

T - Top of document
B - Bottom of document
S - Start of line
E - End of line
F - Find
A - Find again
I - Find next use of symbol under cursor
D - Find definition of symbol
G - Goto line
O - Toggle insert/overwrite
P - 
V - Paste cut or copied block
J - Join next line

Some commands (Top, Bottom, Find, Find Definition, Goto) drop a temporary
bookmark. This is so you can look around and then go back. You can go back
with EXTEND 6. There may be multiple steps and you can go forward with EXTEND 7.
Explicit temporary bookmarks can be dropped with EXTEND 0

SS E - Delete to end of line
SS Q - Delete to start of line
SS F - Toggle auto format
SS A - Assemble
SS S - Save
SS X - Delete current line (or marked block)
SS Delete - Delete to right (remains in extend mode)

You can mark the start of a line with ;* and a digit 1-4. You can then navigate
back to the bookmark with the extend keys:
1 - Goto bookmark 1 ;*1
2 - Goto bookmark 2 ;*2
3 - Goto bookmark 3 ;*3
4 - Goto bookmark 4 ;*4

@{h2}Marking blocks
There are two kinds of blocks: line and part-of-line

To mark a line block press EXTEND MODE then up or down. The block is shown in
bright yellow. Once you have marked a number of lines you can press:

EDIT - Cancel block mark
C    - Copy block (if no block marked it copies current line)
X    - Cut block (if no block marked it cuts current line)
SS X - Delete block

You can write out the current block from the @{b}Block@{ub} menu. You can
also join a block from the file store with @{b}Join@{ub} on the
@{b}Block@{ub} menu.


@{h3}Marking parts of a line
You can mark part of a line by pressing EXTEND MODE and then left or right.

@node ASSEMBLER
@prev MAIN
@{c}@{h1}Assembler
The Astrum assembler is a two pass assembler which means it goes through the
source code twice. On the first pass it syntax checks the source code and
determines the code layout and in particular the value of each label. The
second pass generates the machine code and data. The resulting machine code and
data are written to the filestore. If your source file is game.asm then by
default the written file will be game.bin. You can change this with the OUTPUT
assembler command.

The assembler can be in either upper or lower case but labels and symbols are
case dependent. So FLAGS and flags are different symbols. In general you should
avoid using labels or symbols that are the same as Z80 registers in either
letter case.  On thing to be aware of is using a bracket at the start of a 
constant expression. For example:

     ld bc,(END_SYM-START_SYM)/3

The start bracket makes Astrum think we are loading BC from memory when really
we are loading a constant. This will produce a syntax error because the /3
looks extraneous. To get around this example add a leading +:
     ld bc,+(END_SYM-START_SYM)/3</pre>

This Next version of the assembler has been upgraded to include:

@{"Undocumented Z80 instructions" LINK UNDOCZ80 }
@{"Z80N / Spectrum Next instructions" LINK NEXTZ80 }
@{"Simple Macros" LINK MACROS }
Unused symbol report
@{"Enlarged symbol table support" LINK LARGE_SYMS }
@{"Conditional assembly" LINK COND }
Include files
Listings
@{"Directives" LINK DIRECTIVES }

@node UNDOCZ80
@prev ASSEMBLER
@{c}@{h1}Undocumented Z80 instructions
Astrum supports most if not all undocumented instructions. In particular it
supports the use of high and low bytes of the index registers:

   LD IXH,12
   LD A,IXL

@node NEXTZ80
@prev ASSEMBLER
@{c}@{h1}Z80N / Spectrum Next instructions
Astrum supports the Z80N instructions used by the Spectrum Next. It also
allows you to use the BREAK instruction used by CSpect.

@node MACROS
@prev ASSEMBLER
@{c}@{h1}Macros
Macros are a way of extending the assembler. Macros are effectively extra
commands or instructions. Used sparingly they can really enhance you code.
As an example, inside the Astrum editor is some code that takes a keypress and
decides what to do with it. It uses a list of keys and labels:

 defb 8
 defw LEFT
 defb 9
 defw RIGHT
 defb 11
 defw UP

It would be nicer if each keypress and label were on one line. We can do this
with a macro:

 MACRO KEY_HANDLER key,label
 defb key
 defw label
 ENDM

Now we can write:

 KEY_HANDLER 8,LEFT
 KEY_HANDLER 9,RIGHT
 KEY_HANDLER 11,UP

Macros can call other macros but they must have been declared previously.

You can declare and use labels inside a macro but you cannot reference them from
outside a macro. In general you cannot declare a label more than once but
labels used in a macro are hidden so you do not have to worry about choosing
unique label names from one macro to another.

You could do:

 MACRO VDUN ch,n
 ld b,n
loop
 ld a,ch
 rst 16
 djnz loop
 ENDM

Of course just because you can do something doesn't mean you should! If a
macro is mor than a few lines long it might be worth considering its worth.

Do not choose macro names that would be recognised as something else and do
not use argument names that could be confused with a register name. You can't
use a macro to modify an existing instruction or directive.

@node LARGE_SYMS
@prev ASSEMBLER
@{c}@{h1}Larger Symbol Table
The original Astrum had a 10000 byte symbol table and it just about big enough
to cope with producing ten kilobytes of machine code. The symbol table in this
version is effectively as large as you will need. It can cover multiple memory
banks and I doubt you will run out of space.

@node DIRECTIVES
@prev ASSEMBLER
@{c}@{h1}Directives
The Astrum assembler supports a range of assembler directives. These let you
control various aspects of assembling. . Some directives put bytes into the 
output file others are for controlling various options They are:

DB, DEFB, DEFM, DM
These all do the same and put data into the output. You can either list byte
values individually or as a string. For example:

    MSG    DEFM "Hello World",13,0

DW, DEFW
Similar to DB except that the values are 16-bit. For example:

    LENS   DEFW $23de, 244*3+8

DEFI, DEFC
This takes a string and when it is inserted into the output the last byte of
each string has bit 7 set. This is a useful way of spotting the end of a string
without a formal end-of-string byte like a 0. The Spectrum ROM uses this
technique quite a bit.

DEFZ, DZ
This takes a string and adds a 0 byte at the end of the string

DEFS, DS
This takes a number and inserts that many bytes into the output. The bytes will
all be zero unless there is a second byte value. For example this will insert
32 plus symbols:

           DEFS 32,"+"

IF, IFDEF, IFNDEF, ELSE, ENDIF
View this topic to read about @{"Conditional assembly" LINK COND }

INCLUDE
The include directive allows you to assemble the contents of the given file and
then continue. Includes are often used for common definitions and symbols. An
include file can also contain other includes. For example:

         include mydefs.asm

INCBIN
INCBIN will copy the contents of the file given directly into the assembled
file. For example:

         incbin sprites.bin

LIST
Controls the production of a .lis text file showing the machine code that has
been produced. There are a couple of additional options:

  UNUSED    This will list unused labels after the main listing. This can be
            very useful for spotting code that is no longer used.

  UNUSEDEQU This will list any unused symbols including those defined with the
            EQU directive.

MACRO
View this topic to read about @{"Astrum's macros" LINK MACROS }

OPTION
The options directive lets you control aspects of assembly. You can specify
multiple options in one directive by separating them with a space. The options
are:

  ERRJPJR  If Astrum spots a JP instruction which could be coded as a JR it will
           display an error message. Every byte counts!

  NONEXT   This disables Z80N instructions like MUL and PIXELAD. Using them will
           generate an error

  NOSPECT  This disables CSpect instructions like BREAK. Using them will
           generate an error

  ASTRUM+  The original Astrum+ allowed many pseudo instructions. These are
           disabled by default but using this option will turn on the pseudo
           instructions available in the Microdrive version.

  NOHEADER Do not generate a file header when writing a file.

ORG
This sets base address for assembly. If your code is going to run starting at,
for example, address 34000 then you should start the source with:

         org 34000

OUTPUT
Sets the filename for the assembled code. Normally the code will go to a file
with a .bin file extension. So abc.asm will assemble to abc.bin. However, if you
have the following line it will assemble to mycode

         output mycode

@node COND
@prev ASSEMBLER
@{c}@{h1}Conditional Assembly
With conditional assembly you can easily include or exclude specific blocks
of instructions. The syntax is very similar to BASIC IF statements. There are
three versions of IF: IF,IFDEF and IFNDEF.

For example IFDEF checks whether a symbol is already defined:

DEBUG EQU 1
...
 ifdef DEBUG
  ld hl,buffer
  ld de,buffer+1
  ld bc,1023
  ld (hl),#aa
  ldir
 endif

In the above example if DEBUG has been defined then some code is inserted that
will place #AA into each byte of a buffer. IFNDEF does the opposite test and
the code would be inserted if the symbol wasn't defined. The symbol must already
have been defined for the test to work.

IF allows for general expressions and ELSE can also be used:

 if $<#4000
  ld hl,0
 else
  ld hl,#8000
 endif

In the above example hl is loaded with different values depending on where the
code is being assembled to.

You can use the predefined symbol __ASTRUM__ to include code or directives
specifically when being assembled with Astrum:

 ifdef __ASTRUM__
  LIST
 end
@node DEBUG
@prev MAIN
@{c}@{h1}Debugger
Writing a Z80 debugger that runs in software alongside the code you want to
debug is a bit like trying to catch a lion: the lion really has to want to be
caught. Whether the Astrum debugger is useful to you will really depend on what
your code does and which bits you want to debug. It has been used to 
successfully debug quite a complicated piece of code and it made stepping and
analysing the code quite easy. Like the lion, if you and your code want to use
the debugger you can!

When the assembler has successfully completed you have a binary file. The 
assembler keeps the symbol tables in memory and the debugger can use these to
help you debug your code.

When your code is to be debugged, Astrum will load a version of the debugger
that lives below your codes ORG. Hopefully that will mean the debugger will be
out of the way. It also pages out the editor and source code, leaving only the
portion of Astrum between 26000 and 32767 visible. This portion is needed to
return from the debugger.

You can run the debugger separately. Load the appropriate debugger, they are 
marked with the load address. For example if you need the one that loads at
$c000 then do:

    LOAD "debugc000" code $c000
    rand usr $c000

@{h2}Commands
In the below commands xxxx denotes a 16-bit number. This can be a hex number,
a decimal number (if preceded by a =) or a symbol from your assembler. It can
also take simple expressions in involving +. So BUFFER+10 is valid for 16 bytes
past BUFFER. nn denotes an 8-bit value.

D xxxx nn   Disassemble nn instructions from xxxx. nn can be omitted and will
            default to 8. xxxx can be omitted and will default to the current
            instruction.

P xxxx      Show the value of xxxx

M xxxx nn   Show the contents of nn bytes of memory starting at xxxx. nn can be
            omitted and will default to 16. xxxx can be omitted and will
            default to the value in HL.

R           Show registers

B           Show current 8kB bank mappings.

S           Step (i.e. execute) the current instruction.

O           Step over (i.e. execute) the current instruction. If the instruction is a call then the whole routine will be executed

G xxxx      Get to xxxx. This runs your code until the program counter gets to xxxx.

C           Continue. Runs your code from the current point.

Z xxxx      Set the program counter to xxxx
